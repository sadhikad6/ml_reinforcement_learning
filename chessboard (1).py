# -*- coding: utf-8 -*-
"""chessboard.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1CkRSQ0DqqOcbkdgaJo-5jDX2oiQAGE3P
"""

import numpy as np
import cv2
from matplotlib import pyplot as plt

from google.colab import files
from io import BytesIO
from PIL import Image
uploaded = files.upload()
im = Image.open(BytesIO(uploaded['chessboard.jpg']))

img = cv2.imread('chessboard.jpg')
gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)

corners = cv2.goodFeaturesToTrack(gray,25,0.01,10)
corners = np.int0(corners)

for i in corners:
    x,y = i.ravel()
    cv2.circle(img,(x,y),3,255,-1)

plt.imshow(gray), plt.show()
plt.imshow(img),plt.show()

filename = 'chessboard.jpg'
img = cv2.imread(filename)
gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
height, width, channels = img.shape
print(height, width, channels)

corners = cv2.goodFeaturesToTrack(gray,30,0.01,50)
corners = np.int0(corners)

for i in corners:
    x,y = i.ravel()
    cv2.circle(img,(x,y),6,255,-1)

cv2.imwrite('result.png',img)
plt.imshow(img),plt.show()

import numpy as np
import cv2
import glob2 as glob
import matplotlib.pyplot as plt


img = cv2.imread(filename)
image_inverted = np.array(255-img)
gray = cv2.cvtColor(img,cv2.COLOR_RGB2GRAY)
chessboard_flags = cv2.CALIB_CB_ADAPTIVE_THRESH
ret, corners = cv2.findChessboardCorners(gray, (6,6), chessboard_flags)
print (ret)
plt.imshow(image_inverted),plt.show()

import cv2
import numpy as np
import time

start = time.time()

from google.colab import files
from io import BytesIO
from PIL import Image
uploaded = files.upload()
im = Image.open(BytesIO(uploaded['chessboard.jpg']))

filename = 'chessboard.jpg'
img = cv2.imread(filename)
gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)

gray = np.float32(gray)
dst = cv2.cornerHarris(gray,2,3,0.04)

#result is dilated for marking the corners, not important
dst = cv2.dilate(dst,None)

# Threshold for an optimal value, it may vary depending on the image.
img[dst>0.05*dst.max()]=[255,0,0]
potential_corners = set()
max_temp = dst.max()
for x,arr in enumerate(dst):
  #print(arr)
  for y,val in enumerate(arr):
    if (val > 0.05*max_temp):
      img[x,y] = [0,255,0]
      for i in range(4):
        for j in range(4):
          if (x-1+i < 1024 and y-1+j < 1024):
            img[x-1+i,y-1+j] = [0,255,0]
      potential_corners.add((x,y))
    if (val > 0.15*max_temp):
      img[x,y] = [255,0,0]
      for i in range(4):
        for j in range(4):
          if (x-1+i < 1024 and y-1+j < 1024):
            img[x-1+i,y-1+j] = [255,0,0]
      #potential_corners.add((x,y))

print(potential_corners)


#plt.imshow('dst',img),plt.show()
plt.imshow(img),plt.show()
if cv2.waitKey(0) & 0xff == 27:
    cv2.destroyAllWindows()

print(time.time() - start)

import cv2
import numpy as np

filename = 'chessboard.jpg'
img = cv2.imread(filename)
gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)

# find Harris corners
gray = np.float32(gray)
dst = cv2.cornerHarris(gray,2,3,0.04)
dst = cv2.dilate(dst,None)
ret, dst = cv2.threshold(dst,0.01*dst.max(),255,0)
dst = np.uint8(dst)

# find centroids
ret, labels, stats, centroids = cv2.connectedComponentsWithStats(dst)

# define the criteria to stop and refine the corners
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 100, 0.001)
corners = cv2.cornerSubPix(gray,np.float32(centroids),(5,5),(-1,-1),criteria)

# Now draw them
res = np.hstack((centroids,corners))
res = np.int0(res)
print(res)
img[res[:,1],res[:,0]]=[255,0,0]
img[res[:,3],res[:,2]] = [0,255,0]
for x,arr in enumerate(res):
  temp1 = 0;
  temp2 = 0;
  for y,val in enumerate(arr):
    if (y == 0):
      temp1 = val
    if (y == 1):
      temp2 = val
  img[temp1,temp2] = [255,0,0]

cv2.imwrite('subpixel5.jpg',img)
img2 = cv2.imread('subpixel5.jpg')
plt.imshow(img),plt.show()

#Sadhika Dhanasekar
#Otsu Binarization Code

import cv2 as cv
import numpy as np
from matplotlib import pyplot as plt

from google.colab import files
from io import BytesIO
from PIL import Image
uploaded = files.upload()
im = Image.open(BytesIO(uploaded['chessside.png']))

filename = 'chessside.png'
#img = cv2.imread(filename)
#gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)

img = cv.imread(filename,0)
# global thresholding
ret1,th1 = cv.threshold(img,127,255,cv.THRESH_BINARY)
# Otsu's thresholding
ret2,th2 = cv.threshold(img,0,255,cv.THRESH_BINARY+cv.THRESH_OTSU)
# Otsu's thresholding after Gaussian filtering
blur = cv.GaussianBlur(img,(5,5),0)
ret3,th3 = cv.threshold(blur,0,255,cv.THRESH_BINARY+cv.THRESH_OTSU)
# plot all the images and their histograms
images = [img, 0, th1,
          img, 0, th2,
          blur, 0, th3]
titles = ['Original Noisy Image','Histogram','Global Thresholding (v=127)',
          'Original Noisy Image','Histogram',"Otsu's Thresholding",
          'Gaussian filtered Image','Histogram',"Otsu's Thresholding"]
for i in range(3):
    plt.subplot(3,3,i*3+1),plt.imshow(images[i*3],'gray')
    plt.title(titles[i*3]), plt.xticks([]), plt.yticks([])
    plt.subplot(3,3,i*3+2),plt.hist(images[i*3].ravel(),256)
    plt.title(titles[i*3+1]), plt.xticks([]), plt.yticks([])
    plt.subplot(3,3,i*3+3),plt.imshow(images[i*3+2],'gray')
    plt.title(titles[i*3+2]), plt.xticks([]), plt.yticks([])
plt.show()

import cv2
from matplotlib import pyplot as plt
import numpy as np

from google.colab import files
from io import BytesIO
from PIL import Image
uploaded = files.upload()
im = Image.open(BytesIO(uploaded['chessboard.jpg']))

img = cv2.imread('chessboard.jpg')

gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
edges = cv2.Canny(gray,50,150,apertureSize = 3)

lines = cv2.HoughLines(edges,1,np.pi/180,300)
for line in lines:
  for thing in line:
    rho, theta = thing
    if (theta < 3.10 and theta > 3.0) or (theta > 1.39 and theta < 2.0):
      print(theta)
      a = np.cos(theta)
      b = np.sin(theta)
      x0 = a*rho
      y0 = b*rho
      x1 = int(x0 + 1000*(-b))
      y1 = int(y0 + 1000*(a))
      x2 = int(x0 - 1000*(-b))
      y2 = int(y0 - 1000*(a))

      cv2.line(img,(x1,y1),(x2,y2),(0,0,255),2)

#cv2.imwrite('houghlines3.jpg',img)

'''
gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
edges = cv2.Canny(gray,50,150,apertureSize = 3)
minLineLength = 100
maxLineGap = 10
lines = cv2.HoughLinesP(edges,1,np.pi/180,75,minLineLength,maxLineGap)
for line in lines:
  for thing in line:
    x1,y1,x2,y2 = thing
    cv2.line(img,(x1,y1),(x2,y2),(0,255,0),2)
'''
cv2.imwrite('houghlines5.jpg',img)

plt.imshow(img),plt.show()